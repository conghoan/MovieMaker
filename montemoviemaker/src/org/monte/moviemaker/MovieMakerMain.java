/*
 * @(#)MovieMakerMain.java  
 * 
 * Copyright Â© 2010-2011 Werner Randelshofer, Immensee, Switzerland.
 * All rights reserved.
 * 
 * You may not use, copy or modify this file, except in compliance with the
 * license agreement you entered into with Werner Randelshofer.
 * For details see accompanying license terms.
 */
package org.monte.moviemaker;

import static java.lang.Math.min;

import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.util.Arrays;
import java.util.LinkedList;
import javax.imageio.ImageIO;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.UnsupportedAudioFileException;
import javax.swing.ProgressMonitor;
import javax.swing.SwingWorker;
import javax.swing.filechooser.FileSystemView;

import org.monte.media.Format;
import org.monte.media.mp3.MP3AudioInputStream;
import org.monte.media.quicktime.QuickTimeWriter;

/**
 * A demo for the {@link QuickTimeWriter} class.
 * 
 * @author Werner Randelshofer
 * @version $Id: MovieMakerMain.java 285 2012-11-21 21:04:07Z werner $
 */
public class MovieMakerMain extends javax.swing.JFrame {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	enum WhatToDo {

		REPEAT_SHORTER_TRACK, STRETCH_AND_SQUASH_VIDEO_TRACK, CUT_LONGER_TRACK, DONT_CARE
	}

	private WhatToDo whatToDo = WhatToDo.STRETCH_AND_SQUASH_VIDEO_TRACK;

	/** Creates new form MovieMakerMain */

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	// Code for dispatching events from components to event handlers.

	@SuppressWarnings("rawtypes")
	private void createMovie() {// GEN-FIRST:event_createMovie

		final File soundFile = new File(this.songPath);
		final File imageFolder = new File(this.folderPath);
		final String streaming = this.internetStreaming;

		final Format videoFormat;

		switch (this.compression) {
		case 0:
			videoFormat = QuickTimeWriter.VIDEO_RAW;
			break;
		case 1:
			videoFormat = QuickTimeWriter.VIDEO_ANIMATION;
			break;
		case 2:
			videoFormat = QuickTimeWriter.VIDEO_JPEG;
			break;
		case 3:
		default:
			videoFormat = QuickTimeWriter.VIDEO_PNG;
			break;
		}

		final File movieFile = new File(this.outputFile + ".mov");

		final boolean passThrough = this.passThrough;
		final int width = this.width;
		final int height = this.height;
		final double fps = this.fps;

		// ---------------------------------
		// Create the QuickTime movie
		// ---------------------------------
		SwingWorker w = new SwingWorker() {

			@Override
			protected Object doInBackground() {
				try {

					// Read image files
					File[] imgFiles = null;
					if (imageFolder != null) {
						imgFiles = imageFolder.listFiles(new FileFilter() {

							FileSystemView fsv = FileSystemView
									.getFileSystemView();

							@Override
							public boolean accept(File f) {
								return f.isFile() && !fsv.isHiddenFile(f)
										&& !f.getName().equals("Thumbs.db");
							}
						});
						if (imgFiles != null) {
							Arrays.sort(imgFiles);
						}
					}

					// Delete movie file if it already exists.
					if (movieFile.exists()) {
						movieFile.delete();
					}

					if (imgFiles != null && soundFile != null
							&& imgFiles.length > 0) {
						writeVideoAndAudio(movieFile, imgFiles, soundFile,
								width, height, fps, videoFormat, passThrough,
								streaming);
						System.exit(0);
					}

					return null;
				} catch (Throwable t) {
					return t;
				}
			}

			@Override
			protected void done() {
				Object o;
				try {
					o = get();
				} catch (Exception ex) {
					o = ex;
				}
				if (o instanceof Throwable) {
					Throwable t = (Throwable) o;
					t.printStackTrace();
				}

			}
		};
		w.execute();

	}// GEN-LAST:event_createMovie

	@SuppressWarnings("deprecation")
	private void writeVideoAndAudio(File movieFile, File[] imgFiles,
			File audioFile, int width, int height, double fps,
			Format videoFormat, boolean passThrough, String streaming)
			throws IOException {
		File tmpFile = streaming.equals("none") ? movieFile : new File(
				movieFile.getPath() + ".tmp");
		ProgressMonitor p = new ProgressMonitor(MovieMakerMain.this,
				"Creating " + movieFile.getName(), "Creating Output File...",
				0, imgFiles.length);
		AudioInputStream audioIn = null;
		QuickTimeWriter qtOut = null;
		BufferedImage imgBuffer = null;
		Graphics2D g = null;

		try {
			// Determine audio format
			if (audioFile.getName().toLowerCase().endsWith(".mp3")) {
				audioIn = new MP3AudioInputStream(audioFile);
			} else {
				audioIn = AudioSystem.getAudioInputStream(audioFile);
			}
			AudioFormat audioFormat = audioIn.getFormat();
			boolean isVBR = audioFormat.getProperty("vbr") != null
					&& ((Boolean) audioFormat.getProperty("vbr"))
							.booleanValue();

			// Determine sampleDuration of a single sample
			int asDuration = (int) (audioFormat.getSampleRate() / audioFormat
					.getFrameRate());
			int vsDuration = 100;
			// Create writer
			qtOut = new QuickTimeWriter(tmpFile);
			int at = qtOut.addAudioTrack(audioFormat); // audio in track 0
			int vt = qtOut.addVideoTrack(videoFormat, (int) (fps * vsDuration),
					width, height); // video in track 1
			qtOut.setCompressionQuality(vt, 0.95f);

			// Create audio buffer
			int asSize;
			byte[] audioBuffer;
			if (isVBR) {
				// => variable bit rate: create audio buffer for a single frame
				asSize = audioFormat.getFrameSize();
				audioBuffer = new byte[asSize];
			} else {
				// => fixed bit rate: create audio buffer for half a second
				asSize = audioFormat.getChannels()
						* audioFormat.getSampleSizeInBits() / 8;
				audioBuffer = new byte[(int) (qtOut.getMediaTimeScale(0) / 2 * asSize)];
			}

			// Create video buffer
			if (!passThrough) {
				imgBuffer = new BufferedImage(width, height,
						BufferedImage.TYPE_INT_RGB);
				g = imgBuffer.createGraphics();
				g.setRenderingHint(RenderingHints.KEY_RENDERING,
						RenderingHints.VALUE_RENDER_QUALITY);
			} // Main loop
			int movieTime = 0;
			int imgIndex = 0;
			boolean isAudioDone = false;

			while ((imgIndex < imgFiles.length || !isAudioDone)
					&& !p.isCanceled()) {
				// Advance movie time by half a second (we interleave twice per
				// second)
				movieTime += qtOut.getMovieTimeScale() / 2;

				// Advance audio to movie time + 1 second (audio must be ahead
				// of video by 1 second)
				while (!isAudioDone
						&& qtOut.getTrackDuration(0) < movieTime
								+ qtOut.getMovieTimeScale()) {
					int len = audioIn.read(audioBuffer);
					if (len == -1) {
						isAudioDone = true;
					} else {
						qtOut.writeSamples(at, len / asSize, audioBuffer, 0,
								len, asDuration);
					}
					if (isVBR) {
						// => variable bit rate: format can change at any time
						audioFormat = audioIn.getFormat();
						if (audioFormat == null) {
							break;
						}
						asSize = audioFormat.getFrameSize();
						asDuration = (int) (audioFormat.getSampleRate() / audioFormat
								.getFrameRate());
						if (audioBuffer.length < asSize) {
							audioBuffer = new byte[asSize];
						}
					}
				}

				// Advance video to movie time
				while (imgIndex < imgFiles.length
						&& qtOut.getTrackDuration(1) < movieTime) {
					// catch up with video time
					p.setProgress(imgIndex);
					p.setNote("Processing " + imgFiles[imgIndex].getName());
					if (passThrough) {
						qtOut.writeSample(vt, imgFiles[imgIndex], vsDuration,
								true);
					} else {
						BufferedImage fImg = ImageIO.read(imgFiles[imgIndex]);
						if (fImg == null) {
							continue;
						}
						g.drawImage(fImg, 0, 0, width, height, null);
						fImg.flush();
						qtOut.write(vt, imgBuffer, vsDuration);
					}
					++imgIndex;
				}
			}

			switch (whatToDo) {
			case CUT_LONGER_TRACK: {
				long d0 = qtOut.getTrackDuration(at);
				long d1 = qtOut.getTrackDuration(vt);
				int longerTrack = -1;
				int shorterDuration = -1;
				if (d0 != 0 && d1 != 0) {
					if (d0 > d1) {
						longerTrack = 0;
						shorterDuration = (int) d1;
					} else if (d1 > d0) {
						longerTrack = 1;
						shorterDuration = (int) d0;
					}
				}
				if (longerTrack != -1) {
					LinkedList<QuickTimeWriter.Edit> l = new LinkedList<QuickTimeWriter.Edit>();
					l.add(new QuickTimeWriter.Edit(shorterDuration, 0, 1.0)); // sampleDuration,
																				// media
																				// time,
																				// media
																				// rate
					qtOut.setEditList(longerTrack,
							l.toArray(new QuickTimeWriter.Edit[l.size()]));
				}
			}
				break;
			case DONT_CARE:
				break;
			case REPEAT_SHORTER_TRACK: {
				long d0 = qtOut.getTrackDuration(at);
				long d1 = qtOut.getTrackDuration(vt);
				int shorterTrack = -1;
				int longerTrack = -1;
				int shorterDuration = -1;
				int longerDuration = -1;
				if (d0 != 0 && d1 != 0) {
					if (d0 > d1) {
						shorterTrack = 1;
						longerTrack = 0;
						shorterDuration = (int) d1;
						longerDuration = (int) d0;
					} else if (d1 > d0) {
						longerTrack = 1;
						shorterTrack = 1;
						shorterDuration = (int) d0;
						longerDuration = (int) d1;
					}
				}
				if (longerTrack != -1) {
					LinkedList<QuickTimeWriter.Edit> l = new LinkedList<QuickTimeWriter.Edit>();
					for (; longerDuration > 0; longerDuration -= shorterDuration) {
						l.add(new QuickTimeWriter.Edit(min(shorterDuration,
								longerDuration), 0, 1.0)); // sampleDuration,
															// media time, media
															// rate
					}
					qtOut.setEditList(shorterTrack,
							l.toArray(new QuickTimeWriter.Edit[l.size()]));
				}
			}
				break;
			case STRETCH_AND_SQUASH_VIDEO_TRACK: {
				long d0 = qtOut.getTrackDuration(at);
				long d1 = qtOut.getTrackDuration(vt);
				if (d0 != d1 && d0 != 0 && d1 != 0) {
					LinkedList<QuickTimeWriter.Edit> l = new LinkedList<QuickTimeWriter.Edit>();
					l.add(new QuickTimeWriter.Edit((int) d0, 0, d1 / (float) d0)); // sampleDuration,
																					// media
																					// time,
																					// media
																					// rate
					qtOut.setEditList(1,
							l.toArray(new QuickTimeWriter.Edit[l.size()]));
				}

			}
				break;
			}

			if (streaming.equals("fastStart")) {
				qtOut.toWebOptimizedMovie(movieFile, false);
				tmpFile.delete();
			} else if (streaming.equals("fastStartCompressed")) {
				qtOut.toWebOptimizedMovie(movieFile, true);
				tmpFile.delete();
			}
			qtOut.close();
			qtOut = null;
		} catch (UnsupportedAudioFileException e) {
			IOException ioe = new IOException(e.getMessage());
			ioe.initCause(e);
			throw ioe;
		} finally {
			p.close();
			if (qtOut != null) {
				qtOut.close();
			}
			if (audioIn != null) {
				audioIn.close();

			}
			if (g != null) {
				g.dispose();

			}
			if (imgBuffer != null) {
				imgBuffer.flush();

			}
		}
	}

	/**
	 * @param args
	 *            the command line arguments
	 */
	public static void execute(final String folderPath, final String songPath,
			final int width, final int height, final int fps, final int compression,
			final String internetStreaming, final String outputFile, final boolean passThrough) {
		java.awt.EventQueue.invokeLater(new Runnable() {

			@Override
			public void run() {
			
				MovieMakerMain m = new MovieMakerMain();
				m.folderPath = folderPath;
				m.songPath = songPath;
				m.width = width;
				m.height = height;
				m.fps = fps;
				m.compression = compression;
				m.internetStreaming = internetStreaming;
				m.outputFile = outputFile;
				m.passThrough = passThrough;
				m.createMovie();
			}
		});
	}

	private String folderPath;
	private String songPath;
	private int width;
	private int height;
	private int fps;
	private int compression;
	private String internetStreaming;
	private boolean passThrough;
	private String outputFile;

}
